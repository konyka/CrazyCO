协程的实现
1、定义

问题：协程如应当怎么定义? 
     协程的调度器应当怎么定义？

先来一道设计题：
    设计一个协程的运行体R与运行体调度器S的结构体
    1. 运行体R：包含运行状态{就绪，睡眠，等待}，运行体回调函数，回调参数，栈指针，栈大小，当前运行体
    2. 调度器S：包含执行集合{就绪，睡眠，等待}

这道设计题拆分两个个问题，一个运行体如何高效地在多种状态集合更换。调度器与运行体的功能界限。
 
运行体如何高效地在多种状态集合更换

    新创建的协程，创建完成后，加入到 就绪集合，等待调度器的调度；
    协程在运行完成后，进行IO操作，不过此时IO并未准备好，此时进入 等待状态 集合；
    IO准备就绪，协程开始运行，后续进行sleep操作，此时进入到 睡眠状态 集合。

    就绪(ready)，睡眠(sleep)，等待(wait)三个集合应该采用如何数据结构来存储？

    就绪(ready)集合 并没有设置优先级的选型，所有的协程优先级都一样，所以可以使用 队列 
    来存储就绪的协程，简称为 就绪队列（ready_queue）。

    睡眠(sleep)集合 需要按照睡眠时长进行排序，便于快速检索，采用红黑树来存储，
    简称睡眠树(sleep_tree)。红黑树在工程中，实用形式为<key, value>, key为睡眠时长，value为对应的协程结点。

    等待(wait)集合，其功能是在等待IO准备就绪，等待IO也是有时长的，所以等待(wait)集合采用红黑树的来存储，简称等待树(wait_tree)，此处借鉴nginx的设计。

    不管是睡眠(sleep)集合 ，还是 等待(wait)集合，都和时间有关，时间作为key，作为高速
    查询的入口。


    协程属性    数据结构            说明
    id         int          标识
    status     enum         状态： 就绪(ready)，睡眠(sleep)，等待(wait)
    sleep_tree  rbtree      睡眠红黑树
    wait_tree   rbtree      等待红黑树

比如某协程调用了sleep函数，执行的动作：加入睡眠树(sleep_tree)，status |= S即可。

比如某协程在等待树(wait_tree)中，而IO准备就绪，等待的条件就绪，此时状态就需要改变，执行的动作：加入ready队列中，移出等待树(wait_tree)，状态更改status &= ~W 即可。

有一个前提条件就是不管何种运行状态的协程，都在就绪队列中，只是同时包含有其他的运行状态。？？
























