协程的实现
1、定义

问题：协程如应当怎么定义? 
     协程的调度器应当怎么定义？

先来一道设计题：
    设计一个协程的运行体R与运行体调度器S的结构体
    1. 运行体R：包含运行状态{就绪，睡眠，等待}，运行体回调函数，回调参数，栈指针，栈大小，当前运行体
    2. 调度器S：包含执行集合{就绪，睡眠，等待}

这道设计题拆分两个个问题，一个运行体如何高效地在多种状态集合更换。调度器与运行体的功能界限。
 
运行体如何高效地在多种状态集合更换

    新创建的协程，创建完成后，加入到 就绪集合，等待调度器的调度；
    协程在运行完成后，进行IO操作，不过此时IO并未准备好，此时进入 等待状态 集合；
    IO准备就绪，协程开始运行，后续进行sleep操作，此时进入到 睡眠状态 集合。

    就绪(ready)，睡眠(sleep)，等待(wait)三个集合应该采用如何数据结构来存储？

    就绪(ready)集合 并没有设置优先级的选型，所有的协程优先级都一样，所以可以使用 队列 
    来存储就绪的协程，简称为 就绪队列（ready_queue）。

    睡眠(sleep)集合 需要按照睡眠时长进行排序，便于快速检索，采用红黑树来存储，
    简称睡眠树(sleep_tree)。红黑树在工程中，实用形式为<key, value>, key为睡眠时长，value为对应的协程结点。

    等待(wait)集合，其功能是在等待IO准备就绪，等待IO也是有时长的，所以等待(wait)集合采用红黑树的来存储，简称等待树(wait_tree)，此处借鉴nginx的设计。

    不管是睡眠(sleep)集合 ，还是 等待(wait)集合，都和时间有关，时间作为key，作为高速
    查询的入口。


    协程属性            数据结构            说明
    id                  int          标识
    status              enum         状态： 就绪(ready)，睡眠(sleep)，等待(wait)
    sleep_tree_node     rbtree      睡眠红黑树节点
    wait_tree_node      rbtree      等待红黑树节点
    ready_queue_node    queue       就绪队列节点

比如某协程调用了sleep函数，执行的动作：加入睡眠树(sleep_tree)，status |= S即可。

比如某协程在等待树(wait_tree)中，而IO准备就绪，等待的条件就绪，此时状态就需要改变，执行的动作：加入ready队列中，移出等待树(wait_tree)，状态更改status &= ~W 即可。

有一个前提条件就是不管何种运行状态的协程，都在就绪队列中，只是同时包含有其他的运行状态。？？


调度器统筹调度所有的协程，采用单例模式。拥有所有的调度队列，查询队列。

调度器与协程的功能界限

    每一协程都需要使用的而且可能会不同属性的，使用哲学上的思想就是个性的东西，就是协程属性。
    比如id，红黑树节点等与众不同的东西。

    每一协程都需要的而且数据一致的，使用哲学上的思想就是共性的东西，就是调度器的属性。
        比如栈大小的数值，每个协程都一样的、不做更改就可以作为调度器的属性，如果每个协程大小不一致，则可以作为协程的属性。

    用来管理所有协程的属性，作为调度器的属性。
        比如epoll用来管理每一个协程对应的IO，是需要作为调度器属性。

定义一个协程结构体需要哪些域？

    每一个协程拥有自己的上下文环境，需要保存CPU的寄存器状态信息 ctx；
    需要有子过程的回调函数 func；
    需要有子过程回调函数的参数 arg；
    需要定义自己的栈空间 stack；
    需要有自己栈空间的尺寸 stack_size；
    需要定义协程的创建时间 birth；
    需要定义协程当前的运行状态 status；
    需要定当前运行状态的节点（ready_queue_next, sleep_tree_node, sleep_tree_node）；
    需要定义协程id；
    需要定义调度器的全局对象 sched。

协程的核心结构体如下：

typedef struct _mm_coroutine {

    mm_cpu_ctx ctx;         //协程cpu寄存器上下文
    proc_coroutine func;    //子过程的回调函数
    void *arg;              //子过程回调函数的参数
    void *stack;            //自己的栈空间,在这里是由调度器统一设置
    size_t stack_size;      //自己栈空间的尺寸

    mm_coroutine_status status; //协程当前的运行状态
    mm_schedule *sched;     //调度器的全局对象

    uint64_t birth;         //协程的创建时间
    uint64_t id;            //协程id


    RB_ENTRY(_mm_coroutine) sleep_tree_node;        //当前运行状态的节点
    RB_ENTRY(_mm_coroutine) wait_tree_node;         //当前运行状态的节点

    TAILQ_ENTRY(_mm_coroutine) ready_queue_next;    //当前运行状态的节点

} mm_coroutine;

调度器是管理所有协程运行的组件，协程与调度器的运行关系如下所示。

    
    协程A     协程B     协程C     调度器
    yield------------------------>|
                |<---------------resume
                yield------------>|
                        |<-------resume

调度器的属性，需要有保存CPU的寄存器上下文 ctx，

可以从协程运行状态yield到调度器的运行状态。从协程到调度器用yield，从调度器到协程用resume。
以下为调度器的定义：


typedef struct _mm_schedule {
    uint64_t birth;     //调度器的创建时间
    mm_cpu_ctx ctx;     //调度器的cpu寄存器上下文

    struct _mm_coroutine *curr_thread;
    
    //epoll 操作
    int poller_fd;
    int eventfd;
    struct epoll_event eventlist[XXXX];
    int nevents;

    int num_new_events;

    mm_coroutine_queue ready_queue;             //就绪队列
    mm_coroutine_rbtree_sleep sleep_rbtree;     //睡眠rbtree
    mm_coroutine_rbtree_wait wait_rbtree;       //等待rbtree

} mm_schedule;


调度器的实现
        问题：如何调度协程？
    
    调度器的实现，有两种方案，一种是生产者消费者模式，另一种多状态运行。


1、生产者消费者模式

    生产者                                             消费者

    sleep_tree_node-------------
                               |
                               |
                               \/
                            ready_queue--------------> CPU
                               /\
                               |
                               |
    wait_tree_node--------------                              

伪代码逻辑代码如下所示：

while (1) {

        //遍历睡眠集合，将满足条件的节点加入到ready队列
        coroutine *expired = NULL;
        while ((expired = sleep_tree_expired(sched)) != NULL ) {
            TAILQ_ADD(&sched->ready, expired);
        }

        //遍历等待集合，将满足添加的加入到ready队列
        coroutine *wait = NULL;
        int nready = epoll_wait(sched->epfd, events, EVENT_MAX, 1);
        for (i = 0;i < nready;i ++) {
            wait = wait_tree_search(events[i].data.fd);
            TAILQ_ADD(&sched->ready, wait);
        }

        // 使用resume恢复ready状态的协程运行权
        while (!TAILQ_EMPTY(&sched->ready)) {
            coroutine *ready = TAILQ_POP(sched->ready);
            resume(ready);
        }
    }

-----------------------

2、多状态运行：状态机模式

    生产者                                             消费者

    sleep_tree_node-------------------------------------
                                                       |
                                                       |
                                                       \/
     ready_queue-------------------------------------> CPU
                                                       /\
                                                       |
                                                       |
    wait_tree_node--------------------------------------   

逻辑代码如下：

while (1) {

        //遍历睡眠集合，使用resume恢复expired的协程运行权

        coroutine *expired = NULL;
        while ((expired = sleep_tree_expired(sched)) != NULL) {
            resume(expired);
        }

        //遍历等待集合，使用resume恢复wait的协程运行权

        coroutine *wait = NULL;
        int nready = epoll_wait(sched->epfd, events, EVENT_MAX, 1);
        for (i = 0;i < nready;i ++) {
            wait = wait_tree_search(events[i].data.fd);
            resume(wait);
        }

        // 使用resume恢复ready的协程运行权
        
        while (!TAILQ_EMPTY(sched->ready)) {
            coroutine *ready = TAILQ_POP(sched->ready);
            resume(ready);
        }
    }

------------------------------










































